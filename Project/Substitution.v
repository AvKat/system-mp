Require Import SystemMP.Project.Inversion.
Require Import SystemMP.Project.Helpers.
Require Import Coq.Program.Equality.
Require Import SystemMP.Meta.AssocList.

Ltac rewrite_nil_concat :=
  rewrite <- app_nil_1.

(* Lemma 6.1, 6.2, 6.5 *)

Lemma subst_path_aux :
  (forall E_,
    wf_env E_ ->
    forall E F (p : pth) z S,
      E_ = E ++ (z, bind_val S) :: F ->
      typing F p S ->
      wf_env ((emap (subst_bp z p) E) ++ F)) /\
  (forall E_ T,
    wf_typ E_ T ->
    forall E F (p : pth) z S,
      E_ = E ++ (z, bind_val S) :: F ->
      (* NOTE: This is a bit different from the paper *)
      wf_env E_ ->
      typing F p S ->
      wf_typ ((emap (subst_bp z p) E) ++ F) (subst_tp z p T)) /\
  (forall E_ T U,
    sub E_ T U ->
    forall E F (p : pth) z S,
      E_ = E ++ (z, bind_val S) :: F ->
      typing F p S ->
      sub ((emap (subst_bp z p) E) ++ F) (subst_tp z p T) (subst_tp z p U)).
Proof with eauto using typed_path_wf, wf_pth_path, sub_pth_path.
  apply wf_env_typ_sub_ind; intros; subst; simpl; eauto.

  (* wf_env *)

  - exfalso. rewrite_env (E ++ [(z, bind_val S)] ++ F) in H.
    apply nil_neq_one_mid in H...
  - destruct E0; subst...
    + simpl_env. clear - H2.
      dependent induction H2; simpl...
    + rewrite_env (p0 :: E0 ++ [(z, bind_val S)] ++ F) in H1.
      inversion H1; subst.
      simpl. rewrite_nil_concat.
      eapply wf_env_weaken_val...
      unfold emap. simpl. rewrite dom_app, dom_map.
      rewrite dom_app in n. simpl in n.
      fsetdec.
  - destruct E0; subst...
    + simpl_env. clear - H2.
      dependent induction H2; simpl...
    + rewrite_env (p0 :: E0 ++ [(z, bind_val S)] ++ F) in H1.
      inversion H1; subst.
      simpl. rewrite_nil_concat.
      eapply wf_env_weaken_typ...
      unfold emap. simpl. rewrite dom_app, dom_map.
      rewrite dom_app in n. simpl in n.
      fsetdec.

      (* wf_typ *)
  - analyze_binds_uniq b.
    + simpl in H.
      assert (x <> z) by fsetdec.
      destruct (x == z); try fsetdec...
      apply w_var with (T := (subst_tp z p T))...
      apply binds_map_2 with (f := subst_bp z p) in BindsTac.
      simpl in BindsTac.
      unfold emap. eapply binds_app_2...
    + destruct (z == z); try fsetdec.
      (* apply typed_path_wf in H1. *)
      eapply wf_typ_weaken_tail...
      admit.
    + simpl in H2.
      assert (x <> z) by fsetdec.
      destruct (x == z); try fsetdec...
  - analyze_binds_uniq b.
    + simpl in H.
      assert (X <> z) by fsetdec.
      destruct (X == z); try fsetdec...
      apply w_tvar with (T := (subst_tp z p T))...
      apply binds_map_2 with (f := subst_bp z p) in BindsTac.
      simpl in BindsTac.
      unfold emap. eapply binds_app_2...
    + simpl in H2.
      assert (X <> z) by fsetdec.
      destruct (X == z); try fsetdec...
  - pick fresh x and apply w_fun...
    unfold open_tv. rewrite <- subst_tp_open_tv_rec...
    apply (H0 x ltac:(fsetdec) ((x, bind_val S) :: E0) F p z S0 ltac:(auto))...
  - pick fresh x and apply w_tfun...
    unfold open_tv. rewrite <- subst_tp_open_tv_rec...
    apply (H0 x ltac:(fsetdec) ((x, bind_typ S) :: E0) F p z S0 ltac:(auto))...
  - pick fresh x and apply w_pair...
    unfold open_tv. rewrite <- subst_tp_open_tv_rec...
    apply (H0 x ltac:(fsetdec) ((x, bind_val S) :: E0) F p z S0 ltac:(auto))...
  - pick fresh x and apply w_tpair...
    unfold open_tv. rewrite <- subst_tp_open_tv_rec...
    apply (H0 x ltac:(fsetdec) ((x, bind_val S) :: E0) F p z S0 ltac:(auto))...

  (* sub *)
  - apply sub_symm...
    eapply subst_pp_path...
  - assert (WfF : wf_env F) by (eapply wf_env_strengthen_head; eauto).
    analyze_binds_uniq b; simpl in *...
    + destruct (x == z); try fsetdec...
      apply binds_map_2 with (f := subst_bp z p) in BindsTac.
      simpl in BindsTac. constructor...
    + destruct (z == z); try fsetdec...
      inversion BindsTacVal; subst...
      rewrite subst_tp_fresh...
      pose proof (proj2 (inversion_typing_path _ _ _ H1)).
      eapply sub_weaken_tail...
      apply wf_env_strengthen_head in w.
      inversion w; subst...
      eapply wf_typ_fvar_from_env...
    + destruct (x == z); try fsetdec...
      pose proof (wf_env_binds_val_wf _ _ _ WfF BindsTac0).
      rewrite subst_tp_fresh...
      eapply wf_typ_fvar_from_env...
      inversion BindsTacSideCond0...
  - assert (WfF : wf_env F) by (eapply wf_env_strengthen_head; eauto).
    analyze_binds_uniq b; simpl in *...
    + destruct (X == z); try fsetdec...
      apply binds_map_2 with (f := subst_bp z p) in BindsTac.
      simpl in BindsTac.
      eapply sub_tvar...
    + destruct (X == z); try fsetdec...
      pose proof (wf_env_binds_typ_wf _ _ _ WfF BindsTac0).
      rewrite subst_tp_fresh...
      eapply wf_typ_fvar_from_env...
      inversion BindsTacSideCond0...
  - specialize (H E0 F p1 z S0 ltac:(auto) H1).
    simpl in H...
  - specialize (H E0 F p1 z S0 ltac:(auto) H1).
    simpl in H...
  - specialize (H E0 F p1 z S0 ltac:(auto) H1).
    simpl in H...
    unfold open_tp. rewrite subst_tp_open_tp_rec...
    apply sub_snd with (S := (subst_tp z p1 S))...
  - specialize (H E0 F p1 z S0 ltac:(auto) H1).
    simpl in H...
    unfold open_tp. rewrite subst_tp_open_tp_rec...
    apply sub_tsnd with (S := (subst_tp z p1 S))...
  - pick fresh x and apply sub_fun...
    unfold open_tv. repeat rewrite <- subst_tp_open_tv_rec...
    specialize (H0 x ltac:(fsetdec) ((x, bind_val S2) :: E0))...
    simpl in H0...
  - pick fresh X and apply sub_tfun...
    unfold open_tv. repeat rewrite <- subst_tp_open_tv_rec...
    specialize (H0 X ltac:(fsetdec) ((X, bind_typ S2) :: E0))...
    simpl in H0...
  - pick fresh x and apply sub_pair...
    unfold open_tv. repeat rewrite <- subst_tp_open_tv_rec...
    specialize (H0 x ltac:(fsetdec) ((x, bind_val S2) :: E0))...
    simpl in H0...
  - pick fresh x and apply sub_tpair...
    unfold open_tv. repeat rewrite <- subst_tp_open_tv_rec...
    specialize (H0 x ltac:(fsetdec) ((x, bind_val S2) :: E0))...
    simpl in H0...
Admitted.

Theorem wf_typ_subst_path : forall E F z S T (p : pth),
  wf_env (E ++ (z, bind_val S) :: F) ->
  wf_typ (E ++ (z, bind_val S) :: F) T ->
  typing F p S ->
  wf_typ ((emap (subst_bp z p) E) ++ F) (subst_tp z p T).
Proof with eauto.
  intros. eapply ((proj1 (proj2 subst_path_aux)) (E ++ (z, bind_val S) :: F))...
Qed.

Theorem sub_subst_path : forall E F z S T U (p : pth),
  sub (E ++ (z, bind_val S) :: F) T U ->
  typing F p S ->
  sub ((emap (subst_bp z p) E) ++ F) (subst_tp z p T) (subst_tp z p U).
Proof with eauto.
  intros. eapply ((proj2 (proj2 subst_path_aux)) (E ++ (z, bind_val S) :: F))...
Qed.

Theorem wf_env_subst_path : forall E F z S (p : pth),
  wf_env (E ++ (z, bind_val S) :: F) ->
  typing F p S ->
  wf_env ((emap (subst_bp z p) E) ++ F).
Proof with eauto.
  intros. eapply (proj1 subst_path_aux)...
Qed.

