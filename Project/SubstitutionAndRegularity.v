Require Import SystemMP.Project.Inversion.
Require Export SystemMP.Project.Helpers.
Require Import Coq.Program.Equality.
Require Import SystemMP.Meta.AssocList.

Ltac rewrite_nil_concat :=
  rewrite <- app_nil_1.

(* Lemma 6.1, 6.2, 6.5 *)

Lemma subst_path_aux :
  (forall E_,
    wf_env E_ ->
    forall E F (p : pth) z S,
      E_ = E ++ (z, bind_val S) :: F ->
      typing F p S ->
      wf_env ((emap (subst_bp z p) E) ++ F)) /\
  (forall E_ T,
    wf_typ E_ T ->
    forall E F (p : pth) z S,
      E_ = E ++ (z, bind_val S) :: F ->
      (* NOTE: This is a bit different from the paper *)
      wf_env E_ ->
      typing F p S ->
      wf_typ ((emap (subst_bp z p) E) ++ F) (subst_tp z p T)) /\
  (forall E_ T U,
    sub E_ T U ->
    forall E F (p : pth) z S,
      E_ = E ++ (z, bind_val S) :: F ->
      typing F p S ->
      sub ((emap (subst_bp z p) E) ++ F) (subst_tp z p T) (subst_tp z p U)).
Proof with eauto using typed_path_wf, wf_pth_path, sub_pth_path, sub_env_wf.
  apply wf_env_typ_sub_ind; intros; subst; simpl; eauto.

  (* wf_env *)

  - exfalso. rewrite_env (E ++ [(z, bind_val S)] ++ F) in H.
    apply nil_neq_one_mid in H...
  - destruct E0; subst...
    + simpl_env. clear - H2.
      dependent induction H2; simpl...
    + rewrite_env (p0 :: E0 ++ [(z, bind_val S)] ++ F) in H1.
      inversion H1; subst.
      simpl. rewrite_nil_concat.
      eapply wf_env_weaken_val...
      unfold emap. simpl. rewrite dom_app, dom_map.
      rewrite dom_app in n. simpl in n.
      fsetdec.
  - destruct E0; subst...
    + simpl_env. clear - H2.
      dependent induction H2; simpl...
    + rewrite_env (p0 :: E0 ++ [(z, bind_val S)] ++ F) in H1.
      inversion H1; subst.
      simpl. rewrite_nil_concat.
      eapply wf_env_weaken_typ...
      unfold emap. simpl. rewrite dom_app, dom_map.
      rewrite dom_app in n. simpl in n.
      fsetdec.

  (* wf_typ *)

  - analyze_binds_uniq b.
    + simpl in *.
      assert (x <> z) by fsetdec.
      destruct (x == z); try fsetdec...
      apply w_var with (T := (subst_tp z p T))...
      apply binds_map_2 with (f := subst_bp z p) in BindsTac.
      simpl in BindsTac.
      unfold emap. eapply binds_app_2...
    + destruct (z == z); try fsetdec.
      eapply wf_typ_weaken_tail...
    + simpl in *.
      assert (x <> z) by fsetdec.
      destruct (x == z); try fsetdec...
  - analyze_binds_uniq b.
    + simpl in *.
      assert (X <> z) by fsetdec.
      destruct (X == z); try fsetdec...
      apply w_tvar with (T := (subst_tp z p T))...
      apply binds_map_2 with (f := subst_bp z p) in BindsTac.
      simpl in BindsTac.
      unfold emap. eapply binds_app_2...
    + simpl in *.
      assert (X <> z) by fsetdec.
      destruct (X == z); try fsetdec...
  - pick fresh x and apply w_fun...
    unfold open_tv. rewrite <- subst_tp_open_tv_commute_fresh...
    apply (H0 x ltac:(fsetdec) ((x, bind_val S) :: E0) F p z S0 ltac:(auto))...
  - pick fresh X and apply w_tfun...
    unfold open_tt.
    rewrite <- subst_tp_open_tt_commute...
    apply (H0 X ltac:(fsetdec) ((X, bind_typ S) :: E0) F p z S0 ltac:(auto))...
  - pick fresh x and apply w_pair...
    unfold open_tv. rewrite <- subst_tp_open_tv_commute_fresh...
    apply (H0 x ltac:(fsetdec) ((x, bind_val S) :: E0) F p z S0 ltac:(auto))...
  - pick fresh x and apply w_tpair...
    unfold open_tv. rewrite <- subst_tp_open_tv_commute_fresh...
    apply (H0 x ltac:(fsetdec) ((x, bind_val S) :: E0) F p z S0 ltac:(auto))...

  (* sub *)

  - apply sub_symm...
    eapply subst_pp_path...
  - assert (WfF : wf_env F) by (eapply wf_env_strengthen_head; eauto).
    analyze_binds_uniq b; simpl in *...
    + destruct (x == z); try fsetdec...
      apply binds_map_2 with (f := subst_bp z p) in BindsTac.
      simpl in BindsTac. constructor...
    + destruct (z == z); try fsetdec...
      inversion BindsTacVal; subst...
      rewrite subst_tp_fresh...
      pose proof (proj2 (inversion_typing_path _ _ _ H1)).
      eapply sub_weaken_tail...
      apply wf_env_strengthen_head in w.
      inversion w; subst...
      eapply wf_typ_fvar_from_env...
    + destruct (x == z); try fsetdec...
      pose proof (wf_env_binds_val_wf _ _ _ WfF BindsTac0).
      rewrite subst_tp_fresh...
      eapply wf_typ_fvar_from_env...
      inversion BindsTacSideCond0...
  - assert (WfF : wf_env F) by (eapply wf_env_strengthen_head; eauto).
    analyze_binds_uniq b; simpl in *...
    + destruct (X == z); try fsetdec...
      apply binds_map_2 with (f := subst_bp z p) in BindsTac.
      simpl in BindsTac.
      eapply sub_tvar...
    + destruct (X == z); try fsetdec...
      pose proof (wf_env_binds_typ_wf _ _ _ WfF BindsTac0).
      rewrite subst_tp_fresh...
      eapply wf_typ_fvar_from_env...
      inversion BindsTacSideCond0...
  - specialize (H E0 F p1 z S0 ltac:(auto) H1).
    simpl in H...
  - specialize (H E0 F p1 z S0 ltac:(auto) H1).
    simpl in H...
  - specialize (H E0 F p1 z S0 ltac:(auto) H1).
    simpl in H...
    unfold open_tp. rewrite subst_tp_open_tp_commute...
    apply sub_snd with (S := (subst_tp z p1 S))...
  - specialize (H E0 F p1 z S0 ltac:(auto) H1).
    simpl in H...
    unfold open_tp. rewrite subst_tp_open_tp_commute...
    apply sub_tsnd with (S := (subst_tp z p1 S))...
  - pick fresh x and apply sub_fun...
    unfold open_tv. repeat rewrite <- subst_tp_open_tv_commute_fresh...
    specialize (H1 x ltac:(fsetdec) ((x, bind_val S2) :: E0))...
    simpl in H1...
  - pick fresh X and apply sub_tfun...
    unfold open_tt. repeat rewrite <- subst_tp_open_tt_commute...
    specialize (H1 X ltac:(fsetdec) ((X, bind_typ S2) :: E0))...
    simpl in H1...
  - pick fresh x and apply sub_pair...
    unfold open_tv. repeat rewrite <- subst_tp_open_tv_commute_fresh...
    specialize (H0 x ltac:(fsetdec) ((x, bind_val S2) :: E0))...
    simpl in H0...
  - pick fresh x and apply sub_tpair...
    unfold open_tv. repeat rewrite <- subst_tp_open_tv_commute_fresh...
    specialize (H0 x ltac:(fsetdec) ((x, bind_val S2) :: E0))...
    simpl in H0...
Qed.

Theorem wf_typ_subst_path : forall E F z S T (p : pth),
  wf_env (E ++ (z, bind_val S) :: F) ->
  wf_typ (E ++ (z, bind_val S) :: F) T ->
  typing F p S ->
  wf_typ ((emap (subst_bp z p) E) ++ F) (subst_tp z p T).
Proof with eauto.
  intros. eapply ((proj1 (proj2 subst_path_aux)) (E ++ (z, bind_val S) :: F))...
Qed.

Theorem sub_subst_path : forall E F z S T U (p : pth),
  sub (E ++ (z, bind_val S) :: F) T U ->
  typing F p S ->
  sub ((emap (subst_bp z p) E) ++ F) (subst_tp z p T) (subst_tp z p U).
Proof with eauto.
  intros. eapply ((proj2 (proj2 subst_path_aux)) (E ++ (z, bind_val S) :: F))...
Qed.

Theorem wf_env_subst_path : forall E F z S (p : pth),
  wf_env (E ++ (z, bind_val S) :: F) ->
  typing F p S ->
  wf_env ((emap (subst_bp z p) E) ++ F).
Proof with eauto.
  intros. eapply (proj1 subst_path_aux)...
Qed.

(* Lemma 5.1 *)

Theorem sub_regular : forall E T U,
  sub E T U ->
  wf_env E /\ wf_typ E T /\ wf_typ E U.
Proof with eauto using wf_env_binds_val_wf, wf_env_binds_typ_wf.
  intros. dependent induction H; repeat split; crush...
  - inversion H4...
  - inversion H4...

  - inversion H4; subst...
    pick fresh x.
    specialize (H8 x ltac:(fsetdec)).
    rewrite_env (nil ++ (x, bind_val S) :: E) in H8.
    eapply wf_typ_subst_path in H8...
    simpl_env in *...
    unfold open_tp.
    rewrite <- subst_tp_open_tv_is_open_tp with (z := x)...
    apply wf_env_weaken_val...
  - inversion H4; subst...
    pick fresh x.
    specialize (H8 x ltac:(fsetdec)).
    rewrite_env (nil ++ (x, bind_val S) :: E) in H8.
    eapply wf_typ_subst_path in H8...
    simpl_env in *...
    unfold open_tp.
    rewrite <- subst_tp_open_tv_is_open_tp with (z := x)...
    apply wf_env_weaken_val...

  - pick fresh x and apply w_fun...
    destruct (H2 x ltac:(fsetdec)) as [_ [_ ?]]...

  - pick fresh X and apply w_tfun...
    destruct (H2 X ltac:(fsetdec)) as [_ [_ ?]]...

  - pick fresh x and apply w_pair...
    destruct (H1 x ltac:(fsetdec)) as [_ [? _]]...
    rewrite_env (nil ++ (x, bind_val S1) :: E).
    eapply wf_typ_narrow_val...
    apply ((proj1 narrowing_val_aux) ((x, bind_val S2) :: E)) with (S := S2)...
  - pick fresh x and apply w_pair...
    destruct (H1 x ltac:(fsetdec)) as [_ [_ ?]]...

  - pick fresh x and apply w_tpair...
    destruct (H1 x ltac:(fsetdec)) as [_ [? _]]...
    rewrite_env (nil ++ (x, bind_val S1) :: E).
    eapply wf_typ_narrow_val...
    apply ((proj1 narrowing_val_aux) ((x, bind_val S2) :: E)) with (S := S2)...
  - pick fresh x and apply w_tpair...
    destruct (H1 x ltac:(fsetdec)) as [_ [_ ?]]...
Qed.
