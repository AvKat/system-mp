Require Import SystemMP.Project.Inversion.
Require Export SystemMP.Project.Helpers.
Require Import Coq.Program.Equality.
Require Import SystemMP.Meta.AssocList.

Ltac rewrite_nil_concat :=
  rewrite <- app_nil_1.

(* ------------------------------ Lemma 6.1, 6.2, 6.5 ------------------------------ *)
Lemma subst_path_aux :
  (forall E_,
    wf_env E_ ->
    forall E F (p : pth) z S,
      E_ = E ++ (z, bind_val S) :: F ->
      typing F p S ->
      wf_env ((emap (subst_bp z p) E) ++ F)) /\
  (forall E_ T,
    wf_typ E_ T ->
    forall E F (p : pth) z S,
      E_ = E ++ (z, bind_val S) :: F ->
      wf_env E_ ->
      typing F p S ->
      wf_typ ((emap (subst_bp z p) E) ++ F) (subst_tp z p T)) /\
  (forall E_ T U,
    sub E_ T U ->
    forall E F (p : pth) z S,
      E_ = E ++ (z, bind_val S) :: F ->
      typing F p S ->
      sub ((emap (subst_bp z p) E) ++ F) (subst_tp z p T) (subst_tp z p U)).
Proof with eauto 5.
  apply wf_env_typ_sub_ind; intros; subst; simpl...

  (* wf_env *)

  - exfalso. rewrite_env (E ++ [(z, bind_val S)] ++ F) in H.
    apply nil_neq_one_mid in H...
  - destruct E0; subst...
    rewrite_env (p0 :: E0 ++ [(z, bind_val S)] ++ F) in H1.
    inversion H1; subst.
    simpl. rewrite_nil_concat.
    eapply wf_env_weaken_val...
    unfold emap. simpl. rewrite dom_app, dom_map.
    rewrite dom_app in n. simpl in n.
    fsetdec.
  - destruct E0; subst...
    rewrite_env (p0 :: E0 ++ [(z, bind_val S)] ++ F) in H1.
    inversion H1; subst.
    simpl. rewrite_nil_concat.
    eapply wf_env_weaken_typ...
    unfold emap. simpl. rewrite dom_app, dom_map.
    rewrite dom_app in n. simpl in n.
    fsetdec.

  (* wf_typ *)

  - analyze_binds_uniq b.
    + simpl in *.
      assert (x <> z) by fsetdec.
      destruct (x == z); try fsetdec...
      apply w_var with (T := (subst_tp z p T))...
      apply binds_map_2 with (f := subst_bp z p) in BindsTac.
      simpl in BindsTac.
      unfold emap. eapply binds_app_2...
    + destruct (z == z); try fsetdec.
      eapply wf_typ_weaken_tail...
    + simpl in *.
      assert (x <> z) by fsetdec.
      destruct (x == z); try fsetdec...
  - analyze_binds_uniq b.
    + simpl in *.
      assert (X <> z) by fsetdec.
      destruct (X == z); try fsetdec...
      apply w_tvar with (T := (subst_tp z p T))...
      apply binds_map_2 with (f := subst_bp z p) in BindsTac.
      simpl in BindsTac.
      unfold emap. eapply binds_app_2...
    + simpl in *.
      assert (X <> z) by fsetdec.
      destruct (X == z); try fsetdec...
  - pick fresh x and apply w_fun...
    unfold open_tp. rewrite <- subst_tp_open_tp_commute_fresh...
    apply (H0 x ltac:(fsetdec) ((x, bind_val S) :: E0) F p z S0 ltac:(auto))...
  - pick fresh X and apply w_tfun...
    unfold open_tt.
    rewrite <- subst_tp_open_tt_commute_fresh...
    apply (H0 X ltac:(fsetdec) ((X, bind_typ S) :: E0) F p z S0 ltac:(auto))...
  - pick fresh x and apply w_pair...
    unfold open_tp. rewrite <- subst_tp_open_tp_commute_fresh...
    apply (H0 x ltac:(fsetdec) ((x, bind_val S) :: E0) F p z S0 ltac:(auto))...
  - pick fresh x and apply w_tpair...
    unfold open_tp. rewrite <- subst_tp_open_tp_commute_fresh...
    apply (H0 x ltac:(fsetdec) ((x, bind_val S) :: E0) F p z S0 ltac:(auto))...

  (* sub *)

  - apply sub_symm...
    eapply subst_pp_path...
  - assert (WfF : wf_env F) by (eapply wf_env_strengthen_head; eauto).
    analyze_binds_uniq b; simpl in *...
    + destruct (x == z); try fsetdec...
      apply binds_map_2 with (f := subst_bp z p) in BindsTac.
      simpl in BindsTac. constructor...
    + destruct (z == z); try fsetdec...
      inversion BindsTacVal; subst...
      rewrite subst_tp_fresh...
      pose proof (proj2 (inversion_typing_path _ _ _ H1)).
      eapply sub_weaken_tail...
      apply wf_env_strengthen_head in w.
      inversion w; subst...
    + destruct (x == z); try fsetdec...
      pose proof (wf_env_binds_val_wf _ _ _ WfF BindsTac0).
      rewrite subst_tp_fresh...
      inversion BindsTacSideCond0...
  - assert (WfF : wf_env F) by (eapply wf_env_strengthen_head; eauto).
    analyze_binds_uniq b; simpl in *...
    + destruct (X == z); try fsetdec...
      apply binds_map_2 with (f := subst_bp z p) in BindsTac.
      simpl in BindsTac.
      eapply sub_tvar...
    + destruct (X == z); try fsetdec...
      pose proof (wf_env_binds_typ_wf _ _ _ WfF BindsTac0).
      rewrite subst_tp_fresh...
      inversion BindsTacSideCond0...
  - specialize (H E0 F p0 z S0 ltac:(auto) H1).
    simpl in H...
    unfold open_tp. rewrite subst_tp_open_tp_commute...
    apply sub_snd with (S := (subst_tp z p0 S))...
  - specialize (H E0 F p0 z S0 ltac:(auto) H1).
    simpl in H...
    unfold open_tp. rewrite subst_tp_open_tp_commute...
    apply sub_tsnd with (S := (subst_tp z p0 S))...
  - pick fresh x and apply sub_fun...
    unfold open_tp. repeat rewrite <- subst_tp_open_tp_commute_fresh...
    specialize (H1 x ltac:(fsetdec) ((x, bind_val S2) :: E0))...
    simpl in H1...
  - pick fresh X and apply sub_tfun...
    unfold open_tt. repeat rewrite <- subst_tp_open_tt_commute_fresh...
    specialize (H1 X ltac:(fsetdec) ((X, bind_typ S2) :: E0))...
    simpl in H1...
  - pick fresh x and apply sub_pair...
    unfold open_tp. repeat rewrite <- subst_tp_open_tp_commute_fresh...
    specialize (H0 x ltac:(fsetdec) ((x, bind_val S2) :: E0))...
    simpl in H0...
  - pick fresh x and apply sub_tpair...
    unfold open_tp. repeat rewrite <- subst_tp_open_tp_commute_fresh...
    specialize (H0 x ltac:(fsetdec) ((x, bind_val S2) :: E0))...
    simpl in H0...
Qed.

Theorem wf_typ_subst_path : forall E F z S T (p : pth),
  wf_env (E ++ (z, bind_val S) :: F) ->
  wf_typ (E ++ (z, bind_val S) :: F) T ->
  typing F p S ->
  wf_typ ((emap (subst_bp z p) E) ++ F) (subst_tp z p T).
Proof with eauto.
  intros. eapply ((proj1 (proj2 subst_path_aux)) (E ++ (z, bind_val S) :: F))...
Qed.

Theorem sub_subst_path : forall E F z S T U (p : pth),
  sub (E ++ (z, bind_val S) :: F) T U ->
  typing F p S ->
  sub ((emap (subst_bp z p) E) ++ F) (subst_tp z p T) (subst_tp z p U).
Proof with eauto.
  intros. eapply ((proj2 (proj2 subst_path_aux)) (E ++ (z, bind_val S) :: F))...
Qed.

Theorem wf_env_subst_path : forall E F z S (p : pth),
  wf_env (E ++ (z, bind_val S) :: F) ->
  typing F p S ->
  wf_env ((emap (subst_bp z p) E) ++ F).
Proof with eauto.
  intros. eapply (proj1 subst_path_aux)...
Qed.

(* ------------------------------ Lemma 5.1 ------------------------------ *)

Theorem sub_regular : forall E T U,
  sub E T U ->
  wf_env E /\ wf_typ E T /\ wf_typ E U.
Proof with eauto 4 using wf_env_binds_val_wf, wf_env_binds_typ_wf.
  intros. dependent induction H; repeat split; crush...
  - inversion H3...
  - inversion H3...

  - inversion H3; subst...
    pick fresh x.
    specialize (H7 x ltac:(fsetdec)).
    rewrite_env (nil ++ (x, bind_val S) :: E) in H7.
    eapply wf_typ_subst_path in H7...
    simpl_env in *...
    unfold open_tp.
    rewrite <- subst_tp_open_tp_is_open_tp with (z := x)...
    eapply t_sub with (S := typ_path (pth_proj1 p))...
  - inversion H3; subst...
    pick fresh x.
    specialize (H7 x ltac:(fsetdec)).
    rewrite_env (nil ++ (x, bind_val S) :: E) in H7.
    eapply wf_typ_subst_path in H7...
    simpl_env in *...
    unfold open_tp.
    rewrite <- subst_tp_open_tp_is_open_tp with (z := x)...
    eapply t_sub with (S := typ_path (pth_proj1 p))...
  - pick fresh x and apply w_fun...
    destruct (H2 x ltac:(fsetdec)) as [_ [_ ?]]...

  - pick fresh X and apply w_tfun...
    destruct (H2 X ltac:(fsetdec)) as [_ [_ ?]]...

  - pick fresh x and apply w_pair...
    destruct (H1 x ltac:(fsetdec)) as [_ [? _]]...
    rewrite_env (nil ++ (x, bind_val S1) :: E).
    eapply wf_typ_narrow_val...
    apply ((proj1 narrowing_val_aux) ((x, bind_val S2) :: E)) with (S := S2)...
  - pick fresh x and apply w_pair...
    destruct (H1 x ltac:(fsetdec)) as [_ [_ ?]]...

  - pick fresh x and apply w_tpair...
    destruct (H1 x ltac:(fsetdec)) as [_ [? _]]...
    rewrite_env (nil ++ (x, bind_val S1) :: E).
    eapply wf_typ_narrow_val...
    apply ((proj1 narrowing_val_aux) ((x, bind_val S2) :: E)) with (S := S2)...
  - pick fresh x and apply w_tpair...
    destruct (H1 x ltac:(fsetdec)) as [_ [_ ?]]...
Qed.

(* ------------------------------ Lemma 6.3, 6.4, 6.6 ------------------------------ *)
Lemma subst_type_aux :
  (forall E_,
    wf_env E_ ->
    forall E F Z S S',
      E_ = E ++ (Z, bind_typ S) :: F ->
      sub F S' S ->
      wf_env ((emap (subst_bt Z S') E) ++ F)) /\
  (forall E_ T,
    wf_typ E_ T ->
    forall E F Z S S',
      E_ = E ++ (Z, bind_typ S) :: F ->
      wf_env E_ ->
      sub F S' S ->
      wf_typ ((emap (subst_bt Z S') E) ++ F) (subst_tt Z S' T)) /\
  (forall E_ T U,
    sub E_ T U ->
    forall E F Z S S',
      E_ = E ++ (Z, bind_typ S) :: F ->
      sub F S' S ->
      sub ((emap (subst_bt Z S') E) ++ F) (subst_tt Z S' T) (subst_tt Z S' U)).
Proof with eauto using typed_path_wf, sub_env_wf, wf_pth_path, sub_pth_path.
  apply wf_env_typ_sub_ind; intros; subst; simpl; eauto.

  (* wf_env *)
  - exfalso. rewrite_env (E ++ [(Z, bind_typ S)] ++ F) in H.
    apply nil_neq_one_mid in H...
  - destruct E0; subst...
    rewrite_env (p :: E0 ++ [(Z, bind_typ S)] ++ F) in H1.
    inversion H1; subst.
    simpl. rewrite_nil_concat.
    eapply wf_env_weaken_val...
    unfold emap. simpl. rewrite dom_app, dom_map.
    rewrite dom_app in n. simpl in n.
    fsetdec.
  - destruct E0; subst...
    rewrite_env (p :: E0 ++ [(Z, bind_typ S)] ++ F) in H1.
    inversion H1; subst.
    simpl. rewrite_nil_concat.
    eapply wf_env_weaken_typ...
    unfold emap. simpl. rewrite dom_app, dom_map.
    rewrite dom_app in n. simpl in n.
    fsetdec.

  (* wf_typ *)
  - analyze_binds_uniq b.
    + simpl in *.
      assert (x <> Z) by fsetdec.
      destruct (x == Z); try fsetdec...
      apply w_var with (T := (subst_tt Z S' T))...
      apply binds_map_2 with (f := subst_bt Z S') in BindsTac.
      simpl in BindsTac.
      unfold emap. eapply binds_app_2...
    + destruct (Z == Z); try fsetdec.
      eapply wf_typ_weaken_tail...
  - analyze_binds_uniq b.
    + simpl in *.
      assert (X <> Z) by fsetdec.
      destruct (X == Z); try fsetdec...
      apply w_tvar with (T := (subst_tt Z S' T))...
      apply binds_map_2 with (f := subst_bt Z S') in BindsTac.
      simpl in BindsTac.
      unfold emap. eapply binds_app_2...
    + destruct (Z == Z); try fsetdec.
      eapply wf_typ_weaken_tail...
      apply sub_regular in H2; destruct H2 as [_ [? _]]...
    + simpl in *.
      assert (X <> Z) by fsetdec.
      destruct (X == Z); try fsetdec...
  - pick fresh x and apply w_fun...
    unfold open_tp. rewrite <- subst_tt_open_tp_commute_fresh...
    specialize (H0 x ltac:(fsetdec) ((x, bind_val S) :: E0) F Z S0 ltac:(auto))...
    destruct (sub_regular _ _ _ H3) as [_ [? _]]...
  - pick fresh X and apply w_tfun...
    unfold open_tt.
    rewrite <- subst_tt_open_tt_commute_fresh...
    specialize (H0 X ltac:(fsetdec) ((X, bind_typ S) :: E0) F Z S0 ltac:(auto))...
    destruct (sub_regular _ _ _ H3) as [_ [? _]]...
  - pick fresh x and apply w_pair...
    unfold open_tp. rewrite <- subst_tt_open_tp_commute_fresh...
    specialize (H0 x ltac:(fsetdec) ((x, bind_val S) :: E0) F Z S0 ltac:(auto))...
    destruct (sub_regular _ _ _ H3) as [_ [? _]]...
  - pick fresh x and apply w_tpair...
    unfold open_tp. rewrite <- subst_tt_open_tp_commute_fresh...
    specialize (H0 x ltac:(fsetdec) ((x, bind_val S) :: E0) F Z S0 ltac:(auto))...
    destruct (sub_regular _ _ _ H3) as [_ [? _]]...

    (* sub *)
  - analyze_binds_uniq b...
    + simpl in *.
      assert (x <> Z) by fsetdec.
      destruct (x == Z); try fsetdec...
      apply binds_map_2 with (f := subst_bt Z S') in BindsTac.
      simpl in BindsTac. constructor...
    + simpl in *.
      assert (x <> Z) by fsetdec.
      destruct (x == Z); try fsetdec...
      constructor...
      eapply binds_app_3...
      rewrite subst_tt_fresh...
      inversion BindsTacSideCond0; subst...
      assert (wf_typ F T)...
      eapply wf_env_binds_val_wf...
  - analyze_binds_uniq b...
    + simpl in *.
      assert (X <> Z) by fsetdec.
      destruct (X == Z); try fsetdec...
      apply binds_map_2 with (f := subst_bt Z S') in BindsTac.
      simpl in BindsTac.
      eapply sub_tvar...
    + destruct (Z == Z); try fsetdec.
      inversion BindsTacVal; subst...
      rewrite subst_tt_fresh...
      apply sub_weaken_tail...
      assert (wf_typ F S)...
      eapply wf_env_strengthen_head in w...
      inversion w; subst...
    + simpl in *.
      assert (X <> Z) by fsetdec.
      destruct (X == Z); try fsetdec...
      constructor...
      eapply binds_app_3...
      rewrite subst_tt_fresh...
      inversion BindsTacSideCond0; subst...
      assert (wf_typ F T)...
      eapply wf_env_binds_typ_wf...
  - unfold open_tp. rewrite subst_tt_open_tp_commute_fresh...
    eapply sub_snd...
    destruct (sub_regular _ _ _ H1) as [_ [? _]]...
  - unfold open_tp. rewrite subst_tt_open_tp_commute_fresh...
    eapply sub_tsnd...
    destruct (sub_regular _ _ _ H1) as [_ [? _]]...
  - pick fresh x and apply sub_fun...
    assert (wf_typ F S') by (destruct (sub_regular _ _ _ H3) as [_ [? _]]; eauto).
    unfold open_tp. repeat rewrite <- subst_tt_open_tp_commute_fresh...
    apply (H1 x ltac:(fsetdec) ((x, bind_val S2) :: E0) F Z S)...
  - pick fresh X and apply sub_tfun...
    assert (wf_typ F S') by (destruct (sub_regular _ _ _ H3) as [_ [? _]]; eauto).
    unfold open_tt. repeat rewrite <- subst_tt_open_tt_commute_fresh...
    apply (H1 X ltac:(fsetdec) ((X, bind_typ S2) :: E0) F Z S)...
  - pick fresh x and apply sub_pair...
    assert (wf_typ F S') by (destruct (sub_regular _ _ _ H2) as [_ [? _]]; eauto).
    unfold open_tp. repeat rewrite <- subst_tt_open_tp_commute_fresh...
    apply (H0 x ltac:(fsetdec) ((x, bind_val S2) :: E0) F Z S)...
  - pick fresh x and apply sub_tpair...
    assert (wf_typ F S') by (destruct (sub_regular _ _ _ H2) as [_ [? _]]; eauto).
    unfold open_tp. repeat rewrite <- subst_tt_open_tp_commute_fresh...
    apply (H0 x ltac:(fsetdec) ((x, bind_val S2) :: E0) F Z S)...
Qed.

Theorem wf_typ_subst_type : forall E F Z S S' T,
  wf_typ (E ++ (Z, bind_typ S) :: F) T ->
  sub F S' S ->
  wf_typ ((emap (subst_bt Z S') E) ++ F) (subst_tt Z S' T).
Proof with eauto.
  intros.
  eapply ((proj1 (proj2 subst_type_aux)) (E ++ (Z, bind_typ S) :: F))...
Qed.

Theorem sub_subst_type : forall E F Z S S' T U,
  sub (E ++ (Z, bind_typ S) :: F) T U ->
  sub F S' S ->
  sub ((emap (subst_bt Z S') E) ++ F) (subst_tt Z S' T) (subst_tt Z S' U).
Proof with eauto.
  intros.
  eapply ((proj2 (proj2 subst_type_aux)) (E ++ (Z, bind_typ S) :: F))...
Qed.

Theorem wf_env_subst_type : forall E F Z S S',
  wf_env (E ++ (Z, bind_typ S) :: F) ->
  sub F S' S ->
  wf_env ((emap (subst_bt Z S') E) ++ F).
Proof with eauto.
  intros.
  eapply (proj1 subst_type_aux)...
Qed.


(* ------------------------------ Lemma 5.2 ------------------------------ *)

Theorem typing_regular : forall E t T,
  typing E t T ->
  wf_env E /\ wf_typ E T.
Proof with eauto 4 using wf_env_binds_val_wf, wf_env_binds_typ_wf.
  intros. dependent induction H; repeat split; crush...
  - destruct (sub_regular _ _ _ H0) as [_ [? ?]]...
  - pick fresh x and apply w_fun...
    destruct (H1 x ltac:(fsetdec)) as [_ ?]...
  - inversion H2; subst...
    pick fresh x.
    specialize (H9 x ltac:(fsetdec)).
    rewrite_env (nil ++ (x, bind_val S) :: E) in H9.
    eapply wf_typ_subst_path in H9...
    simpl_env in *...
    unfold open_tp.
    rewrite <- subst_tp_open_tp_is_open_tp with (z := x)...
  - pick fresh X and apply w_tfun...
    destruct (H1 X ltac:(fsetdec)) as [_ ?]...
  - inversion H2; subst...
    pick fresh X.
    specialize (H7 X ltac:(fsetdec)).
    rewrite_env (nil ++ (X, bind_typ S) :: E) in H7.
    eapply wf_typ_subst_type in H7...
    simpl_env in *...
    unfold open_tt.
    rewrite <- subst_tt_open_tt_is_open_tt with (Z := X)...
Qed.

(* ------------------------------ Lemma 6.7 ------------------------------ *)

Theorem typing_subst_var : forall E F z S t T (x : atom),
  typing (E ++ (z, bind_val S) :: F) t T ->
  typing F x S ->
  typing ((emap (subst_bp z x) E) ++ F) (subst_ev z x t) (subst_tp z x T).
Proof with eauto 4 using wf_env_subst_path, wf_typ_subst_path, sub_subst_path.
  intros. dependent induction H...
  - constructor...
    replace (typ_path (subst_pp z x p)) with (subst_tp z x p)...
  - pick fresh x' and apply t_abs...
    unfold open_tp, open_ev.
    rewrite <- subst_ev_open_ev_commute_fresh...
    rewrite <- subst_tp_open_tp_commute_fresh...
    simpl in *.
    specialize (H1 x' ltac:(fsetdec) ((x', bind_val S0) :: E) F z S ltac:(reflexivity))...
  - unfold open_tp.
    rewrite subst_tp_open_tp_commute...
    eapply t_app...
  - pick fresh x' and apply t_tabs...
    unfold open_tt, open_ev.
    rewrite <- subst_ev_open_ev_commute_fresh...
    rewrite <- subst_tp_open_tt_commute_fresh...
    specialize (H1 x' ltac:(fsetdec) ((x', bind_typ S0) :: E) F z S ltac:(reflexivity))...
  - unfold open_tt.
    rewrite subst_tp_open_tt_commute...
    eapply t_tapp...
  - specialize (IHtyping1 E F z S ltac:(reflexivity) H2).
    specialize (IHtyping2 E F z S ltac:(reflexivity) H2).
    unfold open_tp in *.
    rewrite subst_tp_open_tp_commute in IHtyping2...
    simpl in *.
    destruct (x0 == z); destruct (y == z);
    pick fresh x' and apply t_pair; unfold open_tp...
    all: rewrite <- subst_tp_open_tp_commute_fresh...
    all: replace ((x', bind_val (subst_tp z x S0)) :: emap (subst_bp z x) E ++ F) with
        ((emap (subst_bp z x) ((x', bind_val S0) :: E)) ++ F)...
    all: eapply wf_typ_subst_path...
  - eapply sub_subst_path in H1...
    unfold open_tp in *.
    rewrite subst_tp_open_tp_commute in H1...
    specialize (IHtyping E F z S ltac:(reflexivity) H2).
    simpl in *; destruct (x0 == z);
    pick fresh x' and apply t_tpair; unfold open_tp in *...
    all: replace ((x', bind_val (subst_tp z x S0)) :: emap (subst_bp z x) E ++ F) with
        ((emap (subst_bp z x) ((x', bind_val S0) :: E)) ++ F)...
    all: rewrite <- subst_tp_open_tp_commute_fresh...
    all: eapply wf_typ_subst_path...
  - pick fresh x' and apply t_let...
    fold subst_ev.
    specialize (H1 x' ltac:(fsetdec)).
    replace ((x', bind_val (subst_tp z x S0)) :: emap (subst_bp z x) E ++ F) with
        ((emap (subst_bp z x) ((x', bind_val S0) :: E)) ++ F)...
    unfold open_ev, open_tp.
    rewrite <- subst_tp_open_tp_commute_fresh...
    rewrite <- subst_ev_open_ev_commute_fresh...
    eapply (H2 x' ltac:(fsetdec) ((x', bind_val S0) :: E) F z S ltac:(reflexivity))...
Qed.

(* ------------------------------ Lemma 6.8 ------------------------------ *)
Theorem typing_subst_type : forall E F Z S S' t T,
  typing (E ++ (Z, bind_typ S) :: F) t T ->
  sub F S' S ->
  typing ((emap (subst_bt Z S') E) ++ F) (subst_et Z S' t) (subst_tt Z S' T).
Proof with eauto 4 using wf_env_subst_type, wf_typ_subst_type, sub_subst_type.
  intros.
  assert (type S') by (destruct (sub_regular _ _ _ H0) as [_ [? _]]; eauto).
  dependent induction H; simpl...
  - constructor...
    replace (typ_path p) with (subst_tt Z S' p)...
  - pick fresh x' and apply t_abs...
    unfold open_tp, open_ev.
    rewrite <- subst_tt_open_tp_commute_fresh...
    rewrite <- subst_et_open_ev_commute_fresh...
    replace ((x', bind_val (subst_tt Z S' S0)) :: emap (subst_bt Z S') E ++ F) with
        ((emap (subst_bt Z S') ((x', bind_val S0) :: E)) ++ F)...
    eapply (H1 x' ltac:(fsetdec) ((x', bind_val S0) :: E) F Z S ltac:(reflexivity))...
  - unfold open_tp.
    rewrite subst_tt_open_tp_commute_fresh...
    eapply t_app...
  - pick fresh x' and apply t_tabs...
    unfold open_tt, open_ev.
    rewrite <- subst_tt_open_tt_commute_fresh...
    rewrite <- subst_et_open_ev_commute_fresh...
    replace ((x', bind_typ (subst_tt Z S' S0)) :: emap (subst_bt Z S') E ++ F) with
        ((emap (subst_bt Z S') ((x', bind_typ S0) :: E)) ++ F)...
    eapply (H1 x' ltac:(fsetdec) ((x', bind_typ S0) :: E) F Z S ltac:(reflexivity))...
  - unfold open_tt.
    rewrite subst_tt_open_tt_commute...
    eapply t_tapp...
  - pick fresh x' and apply t_pair...
    all: unfold open_tp;
         rewrite <- subst_tt_open_tp_commute_fresh...
    specialize (H0 x' ltac:(fsetdec)).
    replace ((x', bind_val (subst_tt Z S' S0)) :: emap (subst_bt Z S') E ++ F) with
        ((emap (subst_bt Z S') ((x', bind_val S0) :: E)) ++ F)...
  - pick fresh x' and apply t_tpair...
    all: unfold open_tp;
         rewrite <- subst_tt_open_tp_commute_fresh...
    specialize (H0 x' ltac:(fsetdec)).
    replace ((x', bind_val (subst_tt Z S' S0)) :: emap (subst_bt Z S') E ++ F) with
        ((emap (subst_bt Z S') ((x', bind_val S0) :: E)) ++ F)...
  - pick fresh x' and apply t_let...
    unfold open_ev, open_tp.
    rewrite <- subst_tt_open_tp_commute_fresh...
    rewrite <- subst_et_open_ev_commute_fresh...
    specialize (H1 x' ltac:(fsetdec)).
    replace ((x', bind_val (subst_tt Z S' S0)) :: emap (subst_bt Z S') E ++ F) with
        ((emap (subst_bt Z S') ((x', bind_val S0) :: E)) ++ F)...
    eapply (H2 x' ltac:(fsetdec) ((x', bind_val S0) :: E) F Z S ltac:(reflexivity))...
Qed.

